import 'dart:convert';
import 'dart:io';

import 'package:analyzer/dart/analysis/analysis_context_collection.dart';
import 'package:analyzer/dart/analysis/results.dart';
import 'package:analyzer/dart/element/element.dart';
import 'package:analyzer/dart/element/nullability_suffix.dart';

void main() async {
  final packageConfig = jsonDecode(File('.dart_tool/package_config.json').readAsStringSync());
  final packages = List<Map<String, dynamic>>
    .from(packageConfig['packages']).where((e) => ['flutter', 'sky_engine'].contains(e['name']));
  final analyzedFilePaths = AnalysisContextCollection(
    includedPaths: packages.map((e) => Uri.parse(e['rootUri'] + '/lib').path).toList(),
  ).contexts.map((e) => e.contextRoot.analyzedFiles()).expand((e) => e);

  final inputData = jsonDecode(File('bin/generate_source_node_data.json').readAsStringSync());
  final types = List<String>.from(inputData['types']);
  final sources = List<String>.from(inputData['sources']);
  final klasses = sources.map((e) => e.split('.').first).toList();
  final options = List<String>.from(inputData['options']);

  final context = AnalysisContextCollection(
    includedPaths: [Directory.current.absolute.path],
  ).contexts.first;

  // <RETURN_TYPE_NAME, <EXECUTABLE_SOURCE, EXECUTABLE_ELEMENT>>
  final Map<String, Map<String, ExecutableElement>> executableCollection = {};

  // Collect ExecutableElements for each ReturnType to resolve the default SourceNode later.
  for (final filePath in analyzedFilePaths) {
    final result = await context.currentSession.getResolvedLibrary2(filePath);
    if (result is! ResolvedLibraryResult) continue;
    for (final element in result.element!.topLevelElements) {
      if (element is! ClassElement || !klasses.contains(element.name)) continue;
      final executables = <ExecutableElement>[
        ...element.constructors,
        ...element.methods.where((e) => e.isStatic),
      ];
      for (final executable in executables) {
        final executableSource = element.name + (executable.name.isEmpty ? '' : '.${executable.name}');
        if (!sources.contains(executableSource)) continue;
        final returnTypeName = executable.returnType.element!.name!;
        executableCollection[returnTypeName] ??= {};
        executableCollection[returnTypeName]![executableSource] = executable;
      }
    }
  }

  final buffers = <StringBuffer>[];
  final buildValueBuffers = <StringBuffer>[];

  for (final executableEntry in executableCollection.values.expand((e) => e.entries)) {
    // executableEntry: <EXECUTABLE_SOURCE, EXECUTABLE_ELEMENT>
    final source = executableEntry.key;
    final returnTypeName = executableEntry.value.returnType.element!.name!;
    final parameters = executableEntry.value.parameters
      .where((e) => !e.hasDeprecated && types.contains(e.type.element!.name!));
    final nodeName = _buildNodeName(source);

    final buffer = StringBuffer();
    buffer.writeln("final $nodeName = SourceNode<$returnTypeName>('$source', Map.unmodifiable({");
    for (final parameter in parameters) {
      final identifier = _buildIdentifier(parameter);
      final parameterTypeName = parameter.type.element!.name!;
      final valueCode = executableCollection[parameterTypeName]?.length == 1
        ? _buildNodeName(executableCollection[parameterTypeName]!.keys.first)
        : 'SourceNode<$parameterTypeName>()';
      buffer.writeln("  '$identifier': $valueCode,");
    }
    buffer.writeln("}));");
    buffers.add(buffer);

    final buildValueBuffer = StringBuffer();
    buildValueBuffer.writeln("  source == '$source' ? $source(");
    for (final parameter in parameters) {
      final label = parameter.isPositional ? '' : '${parameter.name}: ';
      final identifier = _buildIdentifier(parameter);
      final defaultValueCode = parameter.hasDefaultValue? ' ?? ${parameter.defaultValueCode}' : '';
      buildValueBuffer.writeln("    ${label}children['$identifier']!.value$defaultValueCode,");
    }
    buildValueBuffer.writeln("  ) :");
    buildValueBuffers.add(buildValueBuffer);
  }

  final buffer = StringBuffer();
  buffer.writeln("// GENERATED CODE - DO NOT EDIT BY HAND");
  buffer.writeln();
  buffer.writeln("part of 'source_node.dart';");
  buffer.writeln();
  buffer.writeln("// " + '*' * 70);
  buffer.writeln("// Generated by '${Platform.script.pathSegments.last}'");
  buffer.writeln("// " + '*' * 70);
  buffer.writeln();

  buffers.forEach((b) => buffer.writeln(b.toString()));

  buffer.writeln("Object? _buildValue(String source, Map<String, SourceNode> children) =>");
  buildValueBuffers.forEach((b) => buffer.write(b.toString()));
  buffer.writeln("  null;");
  buffer.writeln();

  buffer.writeln("final Map<String, Object> _sourceValues = Map.unmodifiable({");
  options.forEach((e) => buffer.writeln("  '$e': $e,"));
  buffer.writeln("});");

  File('lib/source_node.g.dart').writeAsString(buffer.toString());
}

// **Example Cases**
// 'ColorScheme' => 'colorSchemeNode'
// 'ColorScheme.light' => 'colorSchemeLightNode'
String _buildNodeName(String executableSource) {
  late String nodeName;
  final index = executableSource.indexOf('.');
  if (index < 0) {
    nodeName = executableSource[0].toLowerCase() +
      executableSource.substring(1);
  } else {
    final klass = executableSource.substring(0, index);
    final executable = executableSource.substring(index + 1);
    nodeName = klass[0].toLowerCase() + klass.substring(1) +
      executable[0].toUpperCase() + executable.substring(1);
  }
  return nodeName + 'Node';
}

String _buildIdentifier(ParameterElement parameter) {
  final symbols =
    (parameter.hasDefaultValue ? '@' : '') +
    (parameter.isPositional ? '_' : '') +
    (parameter.isOptional ? '?' : '') +
    (parameter.type.nullabilitySuffix == NullabilitySuffix.none ? '!' : '');
  return '$symbols#${parameter.name}';
}
