import 'dart:convert';
import 'dart:io';

import 'package:analyzer/dart/analysis/analysis_context_collection.dart';
import 'package:analyzer/dart/analysis/results.dart';
import 'package:analyzer/dart/element/element.dart';
import 'package:analyzer/dart/element/nullability_suffix.dart';

void main() async {
  final packageConfig = jsonDecode(File('.dart_tool/package_config.json').readAsStringSync());
  final packages = List<Map<String, dynamic>>
    .from(packageConfig['packages']).where((e) => ['flutter', 'sky_engine'].contains(e['name']));
  final analyzedFilePaths = AnalysisContextCollection(
    includedPaths: packages.map((e) => Uri.parse(e['rootUri'] + '/lib').path).toList(),
  ).contexts.map((e) => e.contextRoot.analyzedFiles()).expand((e) => e);

  final inputData = jsonDecode(File('bin/generate_source_node_data.json').readAsStringSync());
  final types = List<String>.from(inputData['types']);
  final sources = List<String>.from(inputData['sources']);
  final klasses = sources.map((e) => e.split('.').first).toList();
  final options = List<String>.from(inputData['options']);

  final context = AnalysisContextCollection(
    includedPaths: [Directory.current.absolute.path],
  ).contexts.first;

  final buffers = <StringBuffer>[];
  final buildBuffers = <StringBuffer>[];

  for (final filePath in analyzedFilePaths) {
    final result = await context.currentSession.getResolvedLibrary2(filePath);
    if (result is! ResolvedLibraryResult) continue;
    for (final element in result.element!.topLevelElements) {
      if (element is! ClassElement || !klasses.contains(element.name)) continue;
      final executables = <ExecutableElement>[
        ...element.constructors,
        ...element.methods.where((e) => e.isStatic),
      ];
      for (final executable in executables) {
        final source = element.name + (executable.name.isEmpty ? '' : '.${executable.name}');
        if (!sources.contains(source)) continue;
        final nodeName = _buildNodeName(source);
        final returnTypeName = executable.returnType.element!.name!;
        final parameters = executable.parameters
          .where((e) => !e.hasDeprecated && types.contains(e.type.element!.name!));

        buffers.add(() {
          final buffer = StringBuffer();
          buffer.writeln("final $nodeName = SourceNode<$returnTypeName>('$source', Map.unmodifiable({");
          for (final parameter in parameters) {
            final identifier = _buildIdentifier(parameter);
            final typeName = parameter.type.element!.name;
            buffer.writeln("  '$identifier': SourceNode<$typeName>(),");
          }
          buffer.writeln("}));");
          return buffer;
        } ());

        buildBuffers.add(() {
          final buffer = StringBuffer();
          buffer.writeln("  source == '$source' ? $source(");
          for (final parameter in parameters) {
            final identifier = _buildIdentifier(parameter);
            final label = parameter.isPositional ? '' : '${parameter.name}: ';
            final defaultValueCode = parameter.hasDefaultValue ? ' ?? ${parameter.defaultValueCode}' : '';
            buffer.writeln("    ${label}children['$identifier']!.value$defaultValueCode,");
          }
          buffer.writeln("  ) :");
          return buffer;
        } ());
      }
    }
  }

  final buffer = StringBuffer();
  buffer.writeln("// GENERATED CODE - DO NOT EDIT BY HAND");
  buffer.writeln();
  buffer.writeln("part of 'source_node.dart';");
  buffer.writeln();
  buffer.writeln("// " + '*' * 70);
  buffer.writeln("// Generated by '${Platform.script.pathSegments.last}'");
  buffer.writeln("// " + '*' * 70);
  buffer.writeln();

  buffers.forEach((b) => buffer.writeln(b.toString()));

  buffer.writeln("Object? _buildValue(String source, Map<String, SourceNode> children) =>");
  buildBuffers.forEach((b) => buffer.write(b.toString()));
  buffer.writeln("  null;");
  buffer.writeln();

  buffer.writeln("final Map<String, Object> _sourceValues = Map.unmodifiable({");
  options.forEach((e) => buffer.writeln("  '$e': $e,"));
  buffer.writeln("});");

  File('lib/source_node.g.dart').writeAsString(buffer.toString());
}

// ColorScheme => colorSchemeNode
// ColorScheme.light => colorSchemeLightNode
String _buildNodeName(String source) {
  late String nodeName;
  final index = source.indexOf('.');
  if (index < 0) {
    nodeName = source[0].toLowerCase() +
      source.substring(1);
  } else {
    final klass = source.substring(0, index);
    final executable = source.substring(index + 1);
    nodeName = klass[0].toLowerCase() + klass.substring(1) +
      executable[0].toUpperCase() + executable.substring(1);
  }
  return nodeName + 'Node';
}

// Format: [SYMBOLS]#[NAME]
String _buildIdentifier(ParameterElement parameter) {
  final symbols =
    (parameter.hasDefaultValue ? '@' : '') +
    (parameter.isPositional ? '_' : '') +
    (parameter.isOptional ? '?' : '') +
    (parameter.type.nullabilitySuffix == NullabilitySuffix.none ? '!' : '');
  return '$symbols#${parameter.name}';
}
